use bincode::{Decode, Encode};
pub use rpc_ipc_macros::{RpcClient, RpcService};

pub fn encode_data(data: impl Encode) -> Result<Vec<u8>, bincode::error::EncodeError> {
    bincode::encode_to_vec(&data, bincode::config::standard())
}

pub fn decode_data<D: Decode>(buf: &[u8]) -> Result<(D, usize), bincode::error::DecodeError> {
    bincode::decode_from_slice(buf, bincode::config::standard())
}

#[derive(RpcService, RpcClient)]
#[rpc_service(serialize = "bincode")]
pub enum TestRPC {
    Message(Option<String>, String),
    Sum(f32, f32),
    Multiply(f32, f32),
    Divide(f32, f32),
    // response attribute declares its variant type as response type for the listed Variant names
    #[response("Sum", "Divide", "Multiply")]
    Value(f32),
    #[response("Message")]
    MessageRes(String),
}

/*
* TestRPC expands to:

Types Generated by both RpcService or RpcClient derive macros:

pub struct TestRPCRequest {
    pub id: u32,
    pub payload: TestRPCRequestPayload,
}
pub struct TestRPCResponse {
    pub id: u32,
    pub payload: Option<TestRPCResponsePayload>,
    pub error: Option<TestRPCError>,
}
pub struct TestRPCError {
    error_kind: TestRPCErrorKind,
    description: String,
}
pub enum TestRPCErrorKind {
    Timeout,
    InvalidArgument,
    PermissionDenied,
    NotFound,
    Unimplemented,
    Unreachable,
    Internal,
}
pub enum TestRPCRequestPayload {
    Message(Option<String>, String),
    Sum(f32, f32),
    Multiply(f32, f32),
    Divide(f32, f32),
}
pub enum TestRPCResponsePayload {
    Message(String),
    Sum(f32),
    Multiply(f32),
    Divide(f32),
}

Generated traits:

pub trait TestRPCService {
    fn message(&self, arg0: Option<String>, arg1: String,) -> Result<TestRPCResponsePayload, TestRPCError>;
    fn sum(&self, arg0: f32, arg1: f32) -> Result<TestRPCResponsePayload, TestRPCError>;
    fn multiply( &self, arg0: f32, arg1: f32,) -> Result<TestRPCResponsePayload, TestRPCError>;
    fn divide( &self, arg0: f32, arg1: f32,) -> Result<TestRPCResponsePayload, TestRPCError>;
}

pub trait TestRPCClient {
    fn send_request( &self, request: TestRPCRequest,) -> Result<(), Box<dyn std::error::Error>>;
    fn poll_responses(&self);
    fn generate_request_id(&self) -> u32;
    fn message( &self, arg0: Option<String>, arg1: String,) -> Result<(), Box<dyn std::error::Error>> {
        self.send_request(TestRPCRequest {
            id: self.generate_request_id(),
            payload: TestRPCRequestPayload::Message(arg0, arg1),
        })
    }
    fn sum(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        self.send_request(TestRPCRequest {
            id: self.generate_request_id(),
            payload: TestRPCRequestPayload::Sum(arg0, arg1),
        })
    }
    fn multiply(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        self.send_request(TestRPCRequest {
            id: self.generate_request_id(),
            payload: TestRPCRequestPayload::Multiply(arg0, arg1),
        })
    }
    fn divide(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        self.send_request(TestRPCRequest {
            id: self.generate_request_id(),
            payload: TestRPCRequestPayload::Divide(arg0, arg1),
        })
    }
}
*/
