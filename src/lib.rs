use bincode::{Decode, Encode};
pub use rpc_ipc_macros::{RpcClient, RpcService};

pub fn encode_data(data: impl Encode) -> Result<Vec<u8>, bincode::error::EncodeError> {
    bincode::encode_to_vec(&data, bincode::config::standard())
}

pub fn decode_data<D: Decode>(buf: &[u8]) -> Result<(D, usize), bincode::error::DecodeError> {
    bincode::decode_from_slice(buf, bincode::config::standard())
}

#[derive(RpcService, RpcClient)]
#[rpc_service(serialize = "bincode")]
pub enum TestRPC {
    Message(Option<String>, String),
    Sum(f32, f32),
    Multiply(f32, f32),
    Divide(f32, f32),
    // client attribute marks a variant as rpc that the request should handled by the client
    #[client]
    Ping(u128),
    // response attribute declares its variant type as response type for the listed Variant names
    #[response("Sum", "Divide", "Multiply")]
    Value(f32),
    #[response("Message")]
    MessageRes(String),
}

/*
* TestRPC expands to:

Types Generated by both RpcService or RpcClient derive macros:

pub struct Message {
    pub id: u32,
    pub origin: Origin,
    pub payload: Payload,
}

pub enum Origin {
    Service,
    Client,
}

pub enum Payload {
    Request(Req),
    Response(Res),
}

pub enum Req {
    Message(Option<String>, String),
    Sum(f32, f32),
    Multiply(f32, f32),
    Divide(f32, f32),
    Ping(u128),
}

pub enum Res {
    Message(String),
    Sum(f32),
    Multiply(f32),
    Divide(f32),
    Ping(u128),
    Error(TestRPCError),
}

pub struct TestRPCError {
    error: TestRPCErrorKind,
    description: String,
}

pub enum TestRPCErrorKind {
    Timeout,
    InvalidArgument,
    PermissionDenied,
    NotFound,
    Unimplemented,
    Unreachable,
    Internal,
}


Generated traits:

pub trait TestRPCService {
    async fn send_client_message( &self, message: Message) -> Result<(), Box<dyn std::error::Error>>;
    async fn on_request_payload(&mut self, payload: Req) -> Res;
    async fn on_response_payload(&mut self, payload: Res);
    async fn handle_message_request(&self, arg0: Option<String>, arg1: String) -> Res;
    async fn handle_sum_request(&self, arg0: f32, arg1: f32) -> Res;
    async fn handle_multiply_request(&self, arg0: f32, arg1: f32) -> Res;
    async fn handle_divide_request(&self, arg0: f32, arg1: f32) -> Res;
    async fn on_ping_response(&self, arg0: u128);
}

pub trait TestRPCClient {
    fn send_message(&self, request: Message) -> Result<(), Box<dyn std::error::Error>>;
    fn generate_request_id(&self) -> u32;
    fn message( &self, arg0: Option<String>, arg1: String) -> Result<(), Box<dyn std::error::Error>> {
        self.send_message(Message {
            id: self.generate_request_id(),
            origin: Origin::Client,
            payload: Payload::Request(Req::Message(arg0, arg1)),
        })
    }
    fn sum(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        self.send_message(Message {
            id: self.generate_request_id(),
            origin: Origin::Client,
            payload: Payload::Request(Req::Sum(arg0, arg1)),
        })
    }
    fn multiply(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        self.send_message(Message {
            id: self.generate_request_id(),
            origin: Origin::Client,
            payload: Payload::Request(Req::Multiply(arg0, arg1)),
        })
    }
    fn divide(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        self.send_message(Message {
            id: self.generate_request_id(),
            origin: Origin::Client,
            payload: Payload::Request(Req::Divide(arg0, arg1)),
        })
    }
    fn handle_ping_request(&self, arg0: u128) -> Res;
}
*/
